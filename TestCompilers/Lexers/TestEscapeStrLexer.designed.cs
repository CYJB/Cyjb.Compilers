//------------------------------------------------------------------------------
// <auto-generated>
// 此代码由工具生成。
//
// 对此文件的更改可能会导致不正确的行为，并且如果
// 重新生成代码，这些更改将会丢失。
// </auto-generated>
//------------------------------------------------------------------------------

using System.Collections.Generic;
using System.Globalization;
using System.Runtime.CompilerServices;
using Cyjb.Compilers.Lexers;

namespace TestCompilers.Lexers;

public partial class TestEscapeStrLexer 
{
	/// <summary>
	/// 词法分析器的工厂。
	/// </summary>
	public static readonly ILexerFactory<Str> Factory = CreateLexerFactory();

	/// <summary>
	/// 创建词法分析器的工厂。
	/// </summary>
	[CompilerGeneratedAttribute]
	private static ILexerFactory<Str> CreateLexerFactory()
	{
		// 上下文数据
		Dictionary<string, ContextData> contexts = new()
		{
			 { ContextData.Initial, new ContextData(0, ContextData.Initial) },
			 { "str", new ContextData(1, "str") },
			 { "vstr", new ContextData(2, "vstr") }
		};
		// 终结符数据
		TerminalData<Str>[] terminals = new[]
		{
			// 0: \"
			new TerminalData<Str>(action: (TestEscapeStrLexer c) => c.BeginStrAction()),
			// 1: @\"
			new TerminalData<Str>(action: (TestEscapeStrLexer c) => c.BeginVstrAction()),
			// 2: <str, vstr>\"
			new TerminalData<Str>(Str.Str, action: (TestEscapeStrLexer c) => c.EndAction()),
			// 3: <str>\\u[0-9]{4}
			//    <str>\\x[0-9]{2}
			new TerminalData<Str>(action: (TestEscapeStrLexer c) => c.HexEscapeAction()),
			// 4: <str>\\n
			new TerminalData<Str>(action: (TestEscapeStrLexer c) => c.EscapeLFAction()),
			// 5: <str>\\\"
			new TerminalData<Str>(action: (TestEscapeStrLexer c) => c.EscapeQuoteAction()),
			// 6: <str>\\r
			new TerminalData<Str>(action: (TestEscapeStrLexer c) => c.EscapeCRAction()),
			// 7: <*>.
			new TerminalData<Str>(action: (TestEscapeStrLexer c) => c.CopyAction()),
			// 8: <vstr>\"\"
			new TerminalData<Str>(action: (TestEscapeStrLexer c) => c.VstrQuoteAction())
		};
		// 字符类信息
		// 0: ["]
		// 1: [@]
		// 2: [\\]
		// 3: [u]
		// 4: [0-9]
		// 5: [x]
		// 6: [n]
		// 7: [r]
		// 8: [\0-\t\v\f\u000E-!#-/:-?A-[]-mo-qstvwy-\uFFFE]
		// 字符类索引
		uint[] indexes = new[]
		{
			10551294U
		};
		// 字符类列表
		int[] classes = new[]
		{
			8, 8, 8, 8, 8, 8, 8, 8, 8, 8, -1, 8, 8, -1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
			8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
			4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8, 8, 8, 8, 8, 8, 1, 8, 8, 8, 8, 8, 8, 8,
			8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 2, 8, 8, 8,
			8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 6, 8, 8, 8, 7, 8, 8, 3, 8, 8,
			5, 8, 8, 8, 8, 8, 8, 8, 8
		};
		// 字符类 Unicode 类别
		Dictionary<UnicodeCategory, int> categories = new()
		{
			 { UnicodeCategory.Control, 8 }
		};
		// 状态转移
		//      0   1  2  3   4   5   6   7  8 -> Symbols
		//  0  16  17  4  4   4   4   4   4  4
		//  1   6   4  7  4   4   4   4   4  4
		//  2   3   4  4  4   4   4   4   4  4
		//  3   5                              -> 2 conflict 7
		//  4                                  -> 7
		//  5                                  -> 8
		//  6                                  -> 2 conflict 7
		//  7   8         9      10  11  12    -> 7
		//  8                                  -> 5
		//  9                15               
		// 10                13               
		// 11                                  -> 4
		// 12                                  -> 6
		// 13                14               
		// 14                                  -> 3
		// 15                10               
		// 16                                  -> 0 conflict 7
		// 17  18                              -> 7
		// 18                                  -> 1
		// 状态列表
		int[] states = new[]
		{
			19, 22, 25, 28, 32, 36, 40, 44, 48, 52, 55, 58,
			62, 66, 69, 73, 76, 80, 84, 0, -1, 0, 9, 0,
			0, 12, 0, 0, 14, -1, 1, 2, int.MinValue, -1, 1, 7,
			int.MinValue, -1, 1, 8, int.MinValue, -1, 1, 2, 15, -1, 1, 7,
			int.MinValue, -1, 1, 5, 12, -1, 0, 13, -1, 0, int.MinValue, -1,
			1, 4, int.MinValue, -1, 1, 6, 15, -1, 0, int.MinValue, -1, 1,
			3, 19, -1, 0, int.MinValue, -1, 1, 0, 24, -1, 1, 7,
			int.MinValue, -1, 1, 1
		};
		// 后继状态列表
		int[] next = new[]
		{
			16, 17, 4, 4, 4, 4, 4, 4, 4, 6, 4, 7,
			3, 4, 5, 8, 15, 13, 9, 14, 10, 11, 12, 10,
			18
		};
		// 状态检查列表
		int[] check = new[]
		{
			0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
			2, 2, 3, 7, 9, 10, 7, 13, 7, 7, 7, 15,
			17
		};
		// 词法分析器的数据
		LexerData<Str> lexerData = new(contexts,
			terminals,
			new CharClassMap(indexes, classes, categories),
			states,
			next,
			check,
			TrailingType.None,
			false,
			false,
			typeof(TestEscapeStrLexer));
		return new LexerFactory<Str, TestEscapeStrLexer>(lexerData);
	}
}



