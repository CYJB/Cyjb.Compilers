//------------------------------------------------------------------------------
// <auto-generated>
// 此代码由工具生成。
//
// 对此文件的更改可能会导致不正确的行为，并且如果
// 重新生成代码，这些更改将会丢失。
// </auto-generated>
//------------------------------------------------------------------------------

using System.Collections.Generic;
using System.Runtime.CompilerServices;
using Cyjb.Compilers.Parsers;

namespace TestCompilers.Parsers;

public partial class TestCalcParser 
{
	/// <summary>
	/// 语法分析器的工厂。
	/// </summary>
	public static readonly IParserFactory<Calc> Factory = CreateParserFactory();

	/// <summary>
	/// 创建语法分析器的工厂。
	/// </summary>
	[CompilerGeneratedAttribute]
	private static IParserFactory<Calc> CreateParserFactory()
	{
		// 临时符号
		Calc endOfFile = (Calc)(-1);
		Calc symbol_1 = (Calc)(-2);
		// 产生式数据
		ProductionData<Calc>[] productions = new[]
		{
			new ProductionData<Calc>(Calc.E,
				(TestCalcParser c) => c.IdAction(),
				Calc.Id),
			new ProductionData<Calc>(Calc.E,
				(TestCalcParser c) => c.BinaryAction(),
				Calc.E,
				Calc.Add,
				Calc.E),
			new ProductionData<Calc>(Calc.E,
				(TestCalcParser c) => c.BinaryAction(),
				Calc.E,
				Calc.Sub,
				Calc.E),
			new ProductionData<Calc>(Calc.E,
				(TestCalcParser c) => c.BinaryAction(),
				Calc.E,
				Calc.Mul,
				Calc.E),
			new ProductionData<Calc>(Calc.E,
				(TestCalcParser c) => c.BinaryAction(),
				Calc.E,
				Calc.Div,
				Calc.E),
			new ProductionData<Calc>(Calc.E,
				(TestCalcParser c) => c.BinaryAction(),
				Calc.E,
				Calc.Pow,
				Calc.E),
			new ProductionData<Calc>(Calc.E,
				(TestCalcParser c) => c.BraceAction(),
				Calc.LBrace,
				Calc.E,
				Calc.RBrace),
			new ProductionData<Calc>(symbol_1,
				null,
				Calc.E)
		};
		// 状态数据
		ParserStateData<Calc>[] states = new ParserStateData<Calc>[16];
		// 0: 7 E' -> •E
		//    
		//    Id -> s2
		//    LBrace -> s3
		// 
		//    E -> 1
		Dictionary<Calc, ParserAction> action_1 = new()
		{
			 { Calc.Id, ParserAction.Shift(2) },
			 { Calc.LBrace, ParserAction.Shift(3) }
		};
		HashSet<Calc> expecting_1 = new()
		{
			Calc.Id,
			Calc.LBrace
		};
		states[0] = new ParserStateData<Calc>(action_1,
			ParserAction.Error,
			expecting_1,
			productions[7],
			0);
		// 1: 7 E' -> E•
		//    1 E -> E •Add E
		//    2 E -> E •Sub E
		//    3 E -> E •Mul E
		//    4 E -> E •Div E
		//    5 E -> E •Pow E
		//    
		//    Add -> s4
		//    Div -> s7
		//    Mul -> s6
		//    Pow -> s8
		//    Sub -> s5
		//    EOF -> acc
		Dictionary<Calc, ParserAction> action_2 = new()
		{
			 { endOfFile, ParserAction.Accept },
			 { Calc.Add, ParserAction.Shift(4) },
			 { Calc.Sub, ParserAction.Shift(5) },
			 { Calc.Mul, ParserAction.Shift(6) },
			 { Calc.Div, ParserAction.Shift(7) },
			 { Calc.Pow, ParserAction.Shift(8) }
		};
		HashSet<Calc> expecting_2 = new()
		{
			endOfFile,
			Calc.Add,
			Calc.Sub,
			Calc.Mul,
			Calc.Div,
			Calc.Pow
		};
		states[1] = new ParserStateData<Calc>(action_2,
			ParserAction.Error,
			expecting_2,
			productions[7],
			1);
		// 2: 0 E -> Id•
		//    
		//    Add -> r0
		//    Div -> r0
		//    Mul -> r0
		//    Pow -> r0
		//    RBrace -> r0
		//    Sub -> r0
		//    EOF -> r0
		Dictionary<Calc, ParserAction> action_3 = new();
		HashSet<Calc> expecting_3 = new()
		{
			Calc.RBrace,
			Calc.Add,
			Calc.Sub,
			Calc.Mul,
			Calc.Div,
			Calc.Pow,
			endOfFile
		};
		states[2] = new ParserStateData<Calc>(action_3,
			ParserAction.Reduce(0),
			expecting_3,
			productions[0],
			1);
		// 3: 6 E -> LBrace •E RBrace
		//    
		//    Id -> s2
		//    LBrace -> s3
		// 
		//    E -> 9
		states[3] = new ParserStateData<Calc>(action_1,
			ParserAction.Error,
			expecting_1,
			productions[6],
			1);
		// 4: 1 E -> E Add •E
		//    
		//    Id -> s2
		//    LBrace -> s3
		// 
		//    E -> 10
		states[4] = new ParserStateData<Calc>(action_1,
			ParserAction.Error,
			expecting_1,
			productions[1],
			2);
		// 5: 2 E -> E Sub •E
		//    
		//    Id -> s2
		//    LBrace -> s3
		// 
		//    E -> 11
		states[5] = new ParserStateData<Calc>(action_1,
			ParserAction.Error,
			expecting_1,
			productions[2],
			2);
		// 6: 3 E -> E Mul •E
		//    
		//    Id -> s2
		//    LBrace -> s3
		// 
		//    E -> 12
		states[6] = new ParserStateData<Calc>(action_1,
			ParserAction.Error,
			expecting_1,
			productions[3],
			2);
		// 7: 4 E -> E Div •E
		//    
		//    Id -> s2
		//    LBrace -> s3
		// 
		//    E -> 13
		states[7] = new ParserStateData<Calc>(action_1,
			ParserAction.Error,
			expecting_1,
			productions[4],
			2);
		// 8: 5 E -> E Pow •E
		//    
		//    Id -> s2
		//    LBrace -> s3
		// 
		//    E -> 14
		states[8] = new ParserStateData<Calc>(action_1,
			ParserAction.Error,
			expecting_1,
			productions[5],
			2);
		// 9: 6 E -> LBrace E •RBrace
		//    1 E -> E •Add E
		//    2 E -> E •Sub E
		//    3 E -> E •Mul E
		//    4 E -> E •Div E
		//    5 E -> E •Pow E
		//    
		//    Add -> s4
		//    Div -> s7
		//    Mul -> s6
		//    Pow -> s8
		//    RBrace -> s15
		//    Sub -> s5
		Dictionary<Calc, ParserAction> action_4 = new()
		{
			 { Calc.RBrace, ParserAction.Shift(15) },
			 { Calc.Add, ParserAction.Shift(4) },
			 { Calc.Sub, ParserAction.Shift(5) },
			 { Calc.Mul, ParserAction.Shift(6) },
			 { Calc.Div, ParserAction.Shift(7) },
			 { Calc.Pow, ParserAction.Shift(8) }
		};
		HashSet<Calc> expecting_4 = new()
		{
			Calc.RBrace,
			Calc.Add,
			Calc.Sub,
			Calc.Mul,
			Calc.Div,
			Calc.Pow
		};
		states[9] = new ParserStateData<Calc>(action_4,
			ParserAction.Error,
			expecting_4,
			productions[6],
			2);
		// 10: 1 E -> E Add E•
		//     1 E -> E •Add E
		//     2 E -> E •Sub E
		//     3 E -> E •Mul E
		//     4 E -> E •Div E
		//     5 E -> E •Pow E
		//     
		//     Add -> r1
		//     Div -> s7
		//     Mul -> s6
		//     Pow -> r1
		//     RBrace -> r1
		//     Sub -> r1
		//     EOF -> r1
		Dictionary<Calc, ParserAction> action_5 = new()
		{
			 { Calc.Mul, ParserAction.Shift(6) },
			 { Calc.Div, ParserAction.Shift(7) }
		};
		states[10] = new ParserStateData<Calc>(action_5,
			ParserAction.Reduce(1),
			expecting_3,
			productions[1],
			3);
		// 11: 2 E -> E Sub E•
		//     1 E -> E •Add E
		//     2 E -> E •Sub E
		//     3 E -> E •Mul E
		//     4 E -> E •Div E
		//     5 E -> E •Pow E
		//     
		//     Add -> r2
		//     Div -> s7
		//     Mul -> s6
		//     Pow -> r2
		//     RBrace -> r2
		//     Sub -> r2
		//     EOF -> r2
		states[11] = new ParserStateData<Calc>(action_5,
			ParserAction.Reduce(2),
			expecting_3,
			productions[2],
			3);
		// 12: 3 E -> E Mul E•
		//     1 E -> E •Add E
		//     2 E -> E •Sub E
		//     3 E -> E •Mul E
		//     4 E -> E •Div E
		//     5 E -> E •Pow E
		//     
		//     Add -> r3
		//     Div -> r3
		//     Mul -> r3
		//     Pow -> s8
		//     RBrace -> r3
		//     Sub -> r3
		//     EOF -> r3
		Dictionary<Calc, ParserAction> action_6 = new()
		{
			 { Calc.Pow, ParserAction.Shift(8) }
		};
		states[12] = new ParserStateData<Calc>(action_6,
			ParserAction.Reduce(3),
			expecting_3,
			productions[3],
			3);
		// 13: 4 E -> E Div E•
		//     1 E -> E •Add E
		//     2 E -> E •Sub E
		//     3 E -> E •Mul E
		//     4 E -> E •Div E
		//     5 E -> E •Pow E
		//     
		//     Add -> r4
		//     Div -> r4
		//     Mul -> r4
		//     Pow -> s8
		//     RBrace -> r4
		//     Sub -> r4
		//     EOF -> r4
		states[13] = new ParserStateData<Calc>(action_6,
			ParserAction.Reduce(4),
			expecting_3,
			productions[4],
			3);
		// 14: 5 E -> E Pow E•
		//     1 E -> E •Add E
		//     2 E -> E •Sub E
		//     3 E -> E •Mul E
		//     4 E -> E •Div E
		//     5 E -> E •Pow E
		//     
		//     Add -> r5
		//     Div -> r5
		//     Mul -> r5
		//     Pow -> s8
		//     RBrace -> r5
		//     Sub -> r5
		//     EOF -> r5
		states[14] = new ParserStateData<Calc>(action_6,
			ParserAction.Reduce(5),
			expecting_3,
			productions[5],
			3);
		// 15: 6 E -> LBrace E RBrace•
		//     
		//     Add -> r6
		//     Div -> r6
		//     Mul -> r6
		//     Pow -> r6
		//     RBrace -> r6
		//     Sub -> r6
		//     EOF -> r6
		states[15] = new ParserStateData<Calc>(action_3,
			ParserAction.Reduce(6),
			expecting_3,
			productions[6],
			3);
		// 转移数据
		Dictionary<Calc, int> gotoMap = new()
		{
			 { Calc.Add, 18 },
			 { Calc.Sub, 32 },
			 { Calc.Mul, 38 },
			 { Calc.Div, 52 },
			 { Calc.Pow, 58 },
			 { Calc.Id, 9 },
			 { Calc.E, 0 },
			 { Calc.LBrace, 18 },
			 { Calc.RBrace, -8 }
		};
		// 转移的目标
		int[] gotoNext = new[]
		{
			1, 15, -1, 9, 10, 11, 12, 13, 14, 2, -1, -1, 2, 2, 2, 2, 2, 2, 3, 4, -1, 3, 3, 3,
			3, 3, 3, 4, 4, 4, 4, 4, 4, 5, -1, -1, -1, -1, -1, 6, -1, 5, 5, 5, 5, 5, 5, 6,
			6, 6, 6, 6, 6, 7, -1, -1, -1, -1, -1, 8, -1, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8,
			8
		};
		// 转移的检查
		Calc[] gotoCheck = new[]
		{
			Calc.E,
			Calc.RBrace,
			endOfFile,
			Calc.E,
			Calc.E,
			Calc.E,
			Calc.E,
			Calc.E,
			Calc.E,
			Calc.Id,
			endOfFile,
			endOfFile,
			Calc.Id,
			Calc.Id,
			Calc.Id,
			Calc.Id,
			Calc.Id,
			Calc.Id,
			Calc.LBrace,
			Calc.Add,
			endOfFile,
			Calc.LBrace,
			Calc.LBrace,
			Calc.LBrace,
			Calc.LBrace,
			Calc.LBrace,
			Calc.LBrace,
			Calc.Add,
			Calc.Add,
			Calc.Add,
			Calc.Add,
			Calc.Add,
			Calc.Add,
			Calc.Sub,
			endOfFile,
			endOfFile,
			endOfFile,
			endOfFile,
			endOfFile,
			Calc.Mul,
			endOfFile,
			Calc.Sub,
			Calc.Sub,
			Calc.Sub,
			Calc.Sub,
			Calc.Sub,
			Calc.Sub,
			Calc.Mul,
			Calc.Mul,
			Calc.Mul,
			Calc.Mul,
			Calc.Mul,
			Calc.Mul,
			Calc.Div,
			endOfFile,
			endOfFile,
			endOfFile,
			endOfFile,
			endOfFile,
			Calc.Pow,
			endOfFile,
			Calc.Div,
			Calc.Div,
			Calc.Div,
			Calc.Div,
			Calc.Div,
			Calc.Div,
			Calc.Pow,
			Calc.Pow,
			Calc.Pow,
			Calc.Pow,
			Calc.Pow,
			Calc.Pow
		};
		// 语法分析器的数据
		ParserData<Calc> parserData = new(productions,
			null,
			states,
			gotoMap,
			gotoNext,
			gotoCheck);
		return new ParserFactory<Calc, TestCalcParser>(parserData);
	}
}



