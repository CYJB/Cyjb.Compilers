using System.CommandLine;
using Cyjb.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Cyjb.Compilers;

class Program
{
	static async Task<int> Main(string[] args)
	{
		RootCommand rootCommand = new("根据已声明的词法/语法分析控制器生成相应的预编译代码");
		Argument<string> fileArgument = new("file", "已声明的词法/语法分析控制器文件。");
		rootCommand.AddArgument(fileArgument);

		rootCommand.SetHandler((file) =>
		{
			string content;
			try
			{
				content = File.ReadAllText(file);
			}
			catch (Exception ex)
			{
				string fileName = Path.GetFileName(file);
				Console.WriteLine($"{fileName}(0,0): {ex.Message}");
				return;
			}
			// 如果基于语义模型解析，可能需要引入项目中的其它文件和其它引用依赖库，整体更为复杂。
			// 因此这里仅根据语法模型进行解析。
			var root = CSharpSyntaxTree.ParseText(content, CSharpParseOptions.Default, file)
				.GetCompilationUnitRoot();
			TransformationContext context = new();
			// 检查是否存在任何语法错误。
			if (root.ContainsDiagnostics)
			{
				foreach (Diagnostic diagnostic in root.GetDiagnostics())
				{
					context.AddError(diagnostic.GetMessage(), diagnostic.Location);
				}
				return;
			}
			if (root.Accept(new SyntaxVisitor(context)) is CompilationUnitSyntax newRoot && !context.HasError)
			{
				SyntaxFormat format = new(root);
				// 添加对必须命名空间的引用。
				newRoot = newRoot.AddUsings(
					SyntaxBuilder.UsingDirective("System.Collections.Generic", format),
					SyntaxBuilder.UsingDirective("System.Globalization", format)
				).WithLeadingTrivia(
					SyntaxFactory.Comment("//------------------------------------------------------------------------------"),
					format.EndOfLine,
					SyntaxFactory.Comment("// <auto-generated>"),
					format.EndOfLine,
					SyntaxFactory.Comment("// 此代码由工具生成。"),
					format.EndOfLine,
					SyntaxFactory.Comment("//"),
					format.EndOfLine,
					SyntaxFactory.Comment("// 对此文件的更改可能会导致不正确的行为，并且如果"),
					format.EndOfLine,
					SyntaxFactory.Comment("// 重新生成代码，这些更改将会丢失。"),
					format.EndOfLine,
					SyntaxFactory.Comment("// </auto-generated>"),
					format.EndOfLine,
					SyntaxFactory.Comment("//------------------------------------------------------------------------------"),
					format.EndOfLine,
					format.EndOfLine
				);
				Console.Write(newRoot.ToFullString());
			}
		}, fileArgument);
		return await rootCommand.InvokeAsync(args);
	}
}
