using Cyjb.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Cyjb.Compilers;

internal class Program
{
	public static void Main(string[] args)
	{
		if (args.Length == 0)
		{
			return;
		}
		string path = args[0];
		// 如果基于语义模型解析，可能需要引入项目中的其它文件和其它引用依赖库，整体更为复杂。
		// 因此这里仅根据语法模型进行解析。
		var root = CSharpSyntaxTree.ParseText(File.ReadAllText(path), CSharpParseOptions.Default, path)
			.GetCompilationUnitRoot();
		TransformationContext context = new();
		// 检查是否存在任何语法错误。
		if (root.ContainsDiagnostics)
		{
			foreach (Diagnostic diagnostic in root.GetDiagnostics())
			{
				context.AddError(diagnostic.GetMessage(), diagnostic.Location);
			}
			return;
		}
		if (root.Accept(new SyntaxVisitor(context)) is CompilationUnitSyntax newRoot && !context.HasError)
		{
			SyntaxFormat format = new(root);
			// 添加对必须命名空间的引用。
			newRoot = newRoot.AddUsings(
				SyntaxBuilder.UsingDirective("System", format),
				SyntaxBuilder.UsingDirective("System.Collections.Generic", format),
				SyntaxBuilder.UsingDirective("System.Globalization", format),
				SyntaxBuilder.UsingDirective("Cyjb.Text", format)
			).WithLeadingTrivia(
				SyntaxFactory.Comment("//------------------------------------------------------------------------------"),
				format.EndOfLine,
				SyntaxFactory.Comment("// <auto-generated>"),
				format.EndOfLine,
				SyntaxFactory.Comment("// 此代码由工具生成。"),
				format.EndOfLine,
				SyntaxFactory.Comment("//"),
				format.EndOfLine,
				SyntaxFactory.Comment("// 对此文件的更改可能会导致不正确的行为，并且如果"),
				format.EndOfLine,
				SyntaxFactory.Comment("// 重新生成代码，这些更改将会丢失。"),
				format.EndOfLine,
				SyntaxFactory.Comment("// </auto-generated>"),
				format.EndOfLine,
				SyntaxFactory.Comment("//------------------------------------------------------------------------------"),
				format.EndOfLine,
				format.EndOfLine
			);
			Console.Write(newRoot.ToFullString());
		}
	}
}
